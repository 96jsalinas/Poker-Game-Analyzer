# System Architecture: PokerHero-Analyzer

This document outlines the high-level architecture, technology stack, and data flow for the PokerHero-Analyzer application. The system is designed to parse PokerStars hand histories, store them efficiently, perform complex mathematical evaluations, and serve the insights to a web-based user interface.

## ğŸ—ï¸ Technology Stack

| Component | Technology | Rationale |
| :--- | :--- | :--- |
| **Database** | SQLite | Serverless, zero-configuration, and stores the entire database in a local file. Perfect for a fast, local analytical tool. |
| **DB Access** | Raw SQL (`sqlite3`) | Eliminates ORM overhead. Allows for highly optimized, complex analytical queries tailored specifically to our schema. |
| **Data Manipulation** | Pandas & NumPy | Industry standards for aggregating session data, calculating win rates, and manipulating time-series data for the frontend. |
| **Poker Engine** | PokerKit | Handles state management, hand evaluation, and equity calculations. Provides robust foundations for complex poker math. |
| **Frontend UI** | Dash (Plotly) | Pure-Python web framework purpose-built for interactive data dashboards. Tight integration with Pandas and Plotly charts, and sufficient UI flexibility for the drill-down hand replayer (Session â†’ Hand â†’ Action). |

> **Design Philosophy:** Storage is cheap; compute at query time is not. Derived values are pre-calculated at parse time wherever possible. See `DataStructure.MD` for the full "Numbers First, Space is Cheap" rationale.

## ğŸ”„ Data Flow Pipeline

The application follows a strictly linear data processing pipeline, moving from raw text to interactive web insights.

1. **Ingestion:** The user selects a directory containing PokerStars `.txt` hand history files.
   > âš ï¸ **Known format quirk:** PokerStars `.txt` exports are UTF-8 encoded and may include a BOM (`\ufeff`). The ingestion pipeline opens files with `encoding="utf-8-sig"` which transparently strips any BOM. Additionally, CRLF line endings are normalised to `\n` before splitting. If a file is empty (produces zero hand blocks after splitting), a warning is logged and the file is skipped.
2. **Parsing & Validation:** A Python parsing module reads the raw text, uses regex to extract hand actions, and validates the sequence (ensuring pots balance and actions make logical sense).
3. **Storage:** The parsed, structured data is committed to the SQLite database using raw SQL `INSERT` statements, adhering to the atomic relational schema.
  > âš ï¸ **np.int64 parameter bug:** All query functions cast `player_id`, `session_id`, and `hand_id` parameters to Python `int()` before passing to `pd.read_sql_query`. SQLite3 does not reliably accept `numpy.int64` (the type pandas returns for integer columns) as bind parameters â€” it silently returns empty results in some versions.
4. **Analysis Engine:** Upon a frontend request, the Python backend queries the SQLite database. Data is loaded into Pandas DataFrames.
5. **Mathematical Evaluation:** EV is **pre-computed and cached** in `action_ev_cache` via the explicit "ğŸ“Š Calculate EVs" action â€” it is never computed on page load. Other metrics (SPR, MDF, Pot Odds) are pre-calculated at parse time. PokerKit and Pandas handle equity sampling.
6. **Presentation:** The analyzed DataFrames are passed to the web frontend for rendering charts, tables, and hand replayers.

> **DB-First Principle:** Heavy computations (EV, equity) are stored in the database and read at display time. The session report renders instantly by reading `action_ev_cache`; recalculation only happens when the user explicitly requests it.

## ğŸ“‚ Current Directory Structure

All modules are implemented. The frontend uses Dash multi-page routing.

```text
pokerhero-analyzer/
â”œâ”€â”€ src/
â”‚   â””â”€â”€ pokerhero/
â”‚       â”œâ”€â”€ __init__.py
â”‚       â”œâ”€â”€ parser/               # âœ… Implemented
â”‚       â”‚   â”œâ”€â”€ __init__.py
â”‚       â”‚   â”œâ”€â”€ models.py         # SessionData, HandData, HandPlayerData, ActionData, ParsedHand
â”‚       â”‚   â””â”€â”€ hand_parser.py    # HandParser â€” regex-based PokerStars text parser
â”‚       â”œâ”€â”€ database/             # âœ… Implemented
â”‚       â”‚   â”œâ”€â”€ __init__.py
â”‚       â”‚   â”œâ”€â”€ schema.sql        # CREATE TABLE statements for all tables (sessions, hands,
â”‚       â”‚   â”‚                         # hand_players, actions, players, settings, target_settings,
â”‚       â”‚   â”‚                         # action_ev_cache) + indexes on actions (hand_id, player_id,
â”‚       â”‚   â”‚                         # hand_id+sequence)
â”‚       â”‚   â””â”€â”€ db.py             # get_connection, init_db, upsert_player, insert_*, save_parsed_hand,
â”‚       â”‚                         # update_session_financials, get_setting, set_setting, clear_all_data,
â”‚       â”‚                         # get_action_ev, save_action_evs, get_range_settings
â”‚       â”œâ”€â”€ ingestion/            # âœ… Implemented
â”‚       â”‚   â”œâ”€â”€ __init__.py
â”‚       â”‚   â”œâ”€â”€ splitter.py       # split_hands â€” splits raw session text into hand blocks
â”‚       â”‚   â””â”€â”€ pipeline.py       # IngestResult, ingest_file â€” with re-buy detection
â”‚       â”œâ”€â”€ analysis/             # âœ… Implemented
â”‚       â”‚   â”œâ”€â”€ __init__.py
â”‚       â”‚   â”œâ”€â”€ queries.py        # get_sessions, get_hands, get_actions, get_hero_hand_players,
â”‚       â”‚   â”‚                     # get_hero_timeline, get_hero_actions, get_hero_opportunity_actions,
â”‚       â”‚   â”‚                     # get_export_data, get_session_player_stats,
â”‚       â”‚   â”‚                     # get_session_kpis, get_session_hero_actions,
â”‚       â”‚   â”‚                     # get_session_hero_ev_actions, get_session_ev_status,
â”‚       â”‚   â”‚                     # get_session_showdown_evs â†’ DataFrames;
â”‚       â”‚   â”‚                     # all hero query functions accept optional currency_type='real'|'play'|None
â”‚       â”‚   â”œâ”€â”€ ranges.py         # HAND_RANKING (169 hands), build_range (4 pre-flop action types),
â”‚       â”‚   â”‚                     # blend_vpip, blend_pfr, blend_3bet, expand_combos (dead-card filtering),
â”‚       â”‚   â”‚                     # score_combo_vs_board (draw-aware), contract_range
â”‚       â”‚   â””â”€â”€ stats.py          # vpip_pct, pfr_pct, win_rate_bb100, aggression_factor, wtsd_pct,
â”‚       â”‚                         # total_profit, three_bet_pct, cbet_pct, compute_equity, compute_ev,
â”‚       â”‚                         # compute_equity_vs_range, identify_primary_villain,
â”‚       â”‚                         # calculate_session_evs (EV orchestrator),
â”‚       â”‚                         # classify_player (TAG/LAG/Nit/Fish archetype classification)
â”‚       â”œâ”€â”€ frontend/             # âœ… Implemented (multi-page Dash app)
â”‚       â”‚   â”œâ”€â”€ __init__.py
â”‚       â”‚   â”œâ”€â”€ app.py            # create_app() â€” use_pages=True shell, exposes DB_PATH via Flask config;
â”‚       â”‚   â”‚                     # dcc.Store(id="theme-store") + ğŸŒš/ğŸŒ toggle button + _toggle_theme,
â”‚       â”‚   â”‚                     # _sync_theme_button, clientside_callback to toggle body.dark class
â”‚       â”‚   â”œâ”€â”€ assets/
â”‚       â”‚   â”‚   â””â”€â”€ theme.css     # CSS custom properties (:root light defaults + body.dark overrides);
â”‚       â”‚   â”‚                     # Dash 4 design token overrides; color-scheme:dark for native controls;
â”‚       â”‚   â”‚                     # DataTable, Plotly, and traffic-light dark mode rules
â”‚       â”‚   â”œâ”€â”€ upload_handler.py # handle_upload() â€” decode base64, call ingest_file
â”‚       â”‚   â””â”€â”€ pages/
â”‚       â”‚       â”œâ”€â”€ __init__.py
â”‚       â”‚       â”œâ”€â”€ home.py       # "/" â€” navigation hub with links to Upload, Sessions, Dashboard, Settings, Guide
â”‚       â”‚       â”œâ”€â”€ upload.py     # "/upload" â€” drag-and-drop ingestion; hero username persisted to settings
â”‚       â”‚       â”œâ”€â”€ sessions.py   # "/sessions" â€” 4-level drill-down: session list â†’ session report
â”‚       â”‚       â”‚                 # â†’ hand list â†’ action replay; _describe_hand() uses PokerKit to identify
â”‚       â”‚       â”‚                 # best hand at showdown; _build_opponent_profile_card() renders
â”‚       â”‚       â”‚                 # TAG/LAG/Nit/Fish badges; _render_session_report() assembles
â”‚       â”‚       â”‚                 # KPI strip, narrative, EV summary (reads action_ev_cache),
â”‚       â”‚       â”‚                 # Lucky/Unlucky flagged hands; _build_calculate_ev_section() button
â”‚       â”‚       â”‚                 # triggers calculate_session_evs via synchronous callback
â”‚       â”‚       â”œâ”€â”€ dashboard.py  # "/dashboard" â€” KPI cards, bankroll graph, positional stats table
â”‚       â”‚       â”œâ”€â”€ guide.py      # "/guide" â€” in-app user guide: stat definitions, app walkthrough
â”‚       â”‚       â””â”€â”€ settings.py   # "/settings" â€” hero username, Clear DB, Export CSV, range settings
â”‚       â””â”€â”€ config.py             # DB_PATH (overridable via POKERHERO_DB_PATH env var), setup_logging()
â”œâ”€â”€ tests/
â”‚   â”œâ”€â”€ fixtures/                 # 16 .txt hand history snippets (see TestingStrategy.MD)
â”‚   â”œâ”€â”€ test_parser.py            # 164 tests across 15 classes
â”‚   â”œâ”€â”€ test_database.py          # 69 tests across 9 classes (incl. TestSettings, TestFavorites, currency storage, action_ev_cache)
â”‚   â”œâ”€â”€ test_ingestion.py         # 28 tests for pipeline, financials, re-buy detection, logging
â”‚   â”œâ”€â”€ test_sessions.py          # 182 tests: card rendering, hero row highlighting, math cell, sessions nav/breadcrumb/state,
â”‚   â”‚                             # session/hand filters, favourites, DataTable sorting, format helpers,
â”‚   â”‚                             # EV cell display, background callback wiring, EV summary, flagged hands,
â”‚   â”‚                             # showdown section, villain summary, archetype badge, opponent profile card/panel,
â”‚   â”‚                             # session report view + nav, dark mode compatibility
â”‚   â”œâ”€â”€ test_dashboard.py         # 31 tests: position traffic light colouring, KPI highlights, VPIP/PFR gap chart,
â”‚   â”‚                             # stat header tooltips, dark mode compatibility
â”‚   â”œâ”€â”€ test_app_layout.py        # 28 tests: multi-page app registration, home/upload/sessions/dashboard page layouts,
â”‚   â”‚                             # theme toggle (store, button, face emojis, CSS vars)
â”‚   â”œâ”€â”€ test_settings.py          # 15 tests: main settings page layout, target settings sub-page
â”‚   â”œâ”€â”€ test_upload.py            # 7 tests: upload handler, logging
â”‚   â”œâ”€â”€ test_guide.py             # 6 tests: guide page registration and stat sections
â”‚   â””â”€â”€ test_analysis.py          # 139 tests: queries and stats (vpip, pfr, win_rate, AF, wtsd, timeline,
â”‚                                 # 3-bet, c-bet, EV, action_ev_cache, currency filter, session player stats,
â”‚                                 # player archetype classification, ranges, blend formulas, contraction)
â”œâ”€â”€ data/
â”‚   â””â”€â”€ histories/                # Raw .txt session files (git-ignored)
â””â”€â”€ pyproject.toml
```

## âš ï¸ Dash Component Gotchas

Recurring pitfalls specific to the Dash/Plotly frontend layer.

### `dcc.Input` type allow-list
`dcc.Input` only accepts these values for the `type` prop: `"text"`, `"number"`, `"password"`, `"email"`, `"range"`, `"search"`, `"tel"`, `"url"`, `"hidden"`. It does **not** support `"date"`. For date entry fields, use `dcc.Input(type="text")` with a `YYYY-MM-DD` placeholder and compare values as strings in the callback.

### `dash.html` has no `Input` component
The `dash.html` namespace mirrors common HTML block/container elements but does **not** expose `<input>`. Attempting `html.Input(...)` raises `AttributeError: module 'dash.html' has no attribute 'Input'` at runtime. Use `dcc.Input` for all interactive input fields.

### Pattern-matching callbacks fire on component mount (`n_clicks=0`)
When a callback re-renders a container that holds pattern-matching components (e.g. `{"type": "session-row"}`), Dash fires every matching callback for each newly-mounted component with `n_clicks=0`. This causes phantom navigation or side-effects. Always guard the top of pattern-matching `n_clicks` callbacks with:
```python
if not ctx.triggered[0].get("value"):
    raise dash.exceptions.PreventUpdate
```

### CSS `data-*` attributes are not type-safe on Dash components
Passing `**{"data-tip": tooltip}` as a keyword argument to `html.Span()` is rejected by mypy (incompatible type for positional arg). Use a nested child `html.Span(["?", html.Span(tooltip, className="stat-tip")])` with a CSS `:hover` rule to reveal the inner span instead.

---

## âš ï¸ Known Limitations

### PokerStars format only
The parser (`hand_parser.py`) is tightly coupled to the PokerStars `.txt` hand history export format. No other poker platform's export format (e.g. GGPoker, 888poker, partypoker) is supported. Feeding a non-PokerStars file into the ingestion pipeline will result in parse errors or silently empty output. If multi-platform support is added in the future, the parser module will need to be refactored into a platform-specific adapter pattern.

### Multi-currency support (USD and EUR)
The parser handles both USD (`$`) and EUR (`â‚¬`) PokerStars cash game hand histories. EUR files prefix `â‚¬` before every monetary value (stacks, blinds, action amounts, pots) and include a ` EUR` suffix inside the blind parentheses in the header (e.g. `Hold'em No Limit (â‚¬0.02/â‚¬0.05 EUR)`). The currency symbol is captured by `([â‚¬$])?` as group 2 in `_RE_CASH_HEADER`, which shifts all subsequent group indices by one. `_parse_headers()` maps the captured symbol to `'EUR'` / `'USD'` / `'PLAY'` and stores it on `SessionData.currency`. Play-money and tournament chip files use bare numbers with no currency prefix â€” these always produce `currency='PLAY'`.